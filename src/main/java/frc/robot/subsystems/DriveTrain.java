// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.subsystems;


import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    private final static double WHEELBASE = 16.5; // Length between the axis'
    private final static double TRACKWIDTH = 23; // length between two motors on same axis
    
    private final static double RADIUS = Math.sqrt(Math.pow(WHEELBASE, 2) + Math.pow(TRACKWIDTH, 2));

    private final static double TICKS_PER_360 = 1024; // How many ticks in a 360 rotation of the steering column

    private final static double PIDP = 12;
    private final static double PIDI = 0.0001;
    private final static double PIDD = 0;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private Encoder frontLeftSteerEncoder;
private Encoder frontRightSteerEncoder;
private Encoder backLeftSteerEncoder;
private Encoder backRightSteerEncoder;
private Spark frontLeftDrive;
private Spark frontRightDrive;
private Spark backLeftDrive;
private Spark backRightDrive;
private Spark frontLeftSteer;
private Spark frontRightSteer;
private Spark backLeftSteer;
private Spark backRightSteer;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private PIDController frontLeftSwerve;
    private PIDController frontRightSwerve;
    private PIDController backLeftSwerve;
    private PIDController backRightSwerve;

    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
frontLeftSteerEncoder = new Encoder(0, 1, false, EncodingType.k4X);
addChild("FrontLeftSteerEncoder",frontLeftSteerEncoder);
frontLeftSteerEncoder.setDistancePerPulse(1.0);
frontLeftSteerEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        
frontRightSteerEncoder = new Encoder(2, 3, false, EncodingType.k4X);
addChild("FrontRightSteerEncoder",frontRightSteerEncoder);
frontRightSteerEncoder.setDistancePerPulse(1.0);
frontRightSteerEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        
backLeftSteerEncoder = new Encoder(4, 5, false, EncodingType.k4X);
addChild("BackLeftSteerEncoder",backLeftSteerEncoder);
backLeftSteerEncoder.setDistancePerPulse(1.0);
backLeftSteerEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        
backRightSteerEncoder = new Encoder(6, 7, false, EncodingType.k4X);
addChild("BackRightSteerEncoder",backRightSteerEncoder);
backRightSteerEncoder.setDistancePerPulse(1.0);
backRightSteerEncoder.setPIDSourceType(PIDSourceType.kDisplacement);
        
frontLeftDrive = new Spark(0);
addChild("FrontLeftDrive",frontLeftDrive);
frontLeftDrive.setInverted(false);
        
frontRightDrive = new Spark(1);
addChild("FrontRightDrive",frontRightDrive);
frontRightDrive.setInverted(false);
        
backLeftDrive = new Spark(2);
addChild("BackLeftDrive",backLeftDrive);
backLeftDrive.setInverted(false);
        
backRightDrive = new Spark(3);
addChild("BackRightDrive",backRightDrive);
backRightDrive.setInverted(false);
        
frontLeftSteer = new Spark(4);
addChild("FrontLeftSteer",frontLeftSteer);
frontLeftSteer.setInverted(false);
        
frontRightSteer = new Spark(5);
addChild("FrontRightSteer",frontRightSteer);
frontRightSteer.setInverted(false);
        
backLeftSteer = new Spark(6);
addChild("BackLeftSteer",backLeftSteer);
backLeftSteer.setInverted(false);
        
backRightSteer = new Spark(7);
addChild("BackRightSteer",backRightSteer);
backRightSteer.setInverted(false);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // Set up our PIDS
        frontLeftSwerve = new PIDController(PIDP, PIDI, PIDD);
        frontLeftSwerve.enableContinuousInput(0,360);
        frontRightSwerve = new PIDController(PIDP, PIDI, PIDD);
        frontRightSwerve.enableContinuousInput(0,360);
        backLeftSwerve = new PIDController(PIDP, PIDI, PIDD);
        backLeftSwerve.enableContinuousInput(0,360);
        backRightSwerve = new PIDController(PIDP, PIDI, PIDD);
        backRightSwerve.enableContinuousInput(0,360);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.


    public void drive(double rotation, double x, double y){
		double A = x - rotation * (WHEELBASE / RADIUS);
		double B = x + rotation * (WHEELBASE / RADIUS);
		double C = y - rotation * (TRACKWIDTH / RADIUS);
		double D = y + rotation * (TRACKWIDTH / RADIUS);

		double[] ticks = new double[4];
		double[] currentAngles = new double[4];
		double[] speeds = new double[4];
        double[] rotations = new double[4];
        double[] steerSpeeds = new double[4];

		// calculate speed/rotation for each wheel
		speeds[0] = Math.sqrt(Math.pow(B, 2) + Math.pow(C, 2)); //frontright
		rotations[0] = Math.toDegrees(Math.atan2(B, C));
		speeds[1] = Math.sqrt(Math.pow(B, 2) + Math.pow(D, 2)); //frontleft
		rotations[1] = Math.toDegrees(Math.atan2(B, D));
		speeds[2] = Math.sqrt(Math.pow(A, 2) + Math.pow(D, 2)); // backleft
		rotations[2] = Math.toDegrees(Math.atan2(A, D));
		speeds[3] = Math.sqrt(Math.pow(A, 2) + Math.pow(C, 2)); //backright
		rotations[3] = Math.toDegrees(Math.atan2(A, C));

        // Normalize rotations to [0,360] instead of [-180,180]
		for (int i = 0; i < 4; i++) {
			rotations[i] *= -1;
			rotations[i] += 360;
			rotations[i] %= 360;
        }
        
        // Get our current position:
        ticks[0] = frontRightSteerEncoder.get();
        ticks[1] = frontLeftSteerEncoder.get();
        ticks[2] = backLeftSteerEncoder.get();
        ticks[3] = backRightSteerEncoder.get();

        for(int i = 0; i<4; i++){
            currentAngles[i] = ticks[i] / TICKS_PER_360;
        }

		// Figure out if it's shorter to drive a wheel backwards instead:
		for(int i = 0; i<4; i ++){
			double diffReg = diffBetweenDegrees(rotations[i], currentAngles[i]);
			double oppAngle = (rotations[i] + 180) % 360;
			double diffOpp = diffBetweenDegrees(oppAngle, currentAngles[i]);
			if(Math.abs(diffOpp) < Math.abs(diffReg)){
				rotations[i] = oppAngle;
				speeds[i] *= -1;
			}
		}

		boolean shouldRotate = false;

		shouldRotate |= Math.abs(x) > .15;
		shouldRotate |= Math.abs(y) > .15;
		shouldRotate |= Math.abs(rotation) > .15;


		if(shouldRotate){
            // Feed the PID:
            steerSpeeds[0] = frontRightSwerve.calculate(currentAngles[0], rotations[0]);
            steerSpeeds[1] = frontLeftSwerve.calculate(currentAngles[1], rotations[1]);
            steerSpeeds[2] = backLeftSwerve.calculate(currentAngles[2], rotations[2]);
            steerSpeeds[3] = backRightSwerve.calculate(currentAngles[3], rotations[3]);
            frontRightSteer.set(steerSpeeds[0]);
            frontLeftSteer.set(steerSpeeds[1]);
            backLeftSteer.set(steerSpeeds[2]);
            backRightSteer.set(steerSpeeds[3]);
		}


		// normalize speeds to a good speed;
		speeds = normalizeSpeeds(speeds, x, y);
		

        frontLeftDrive.set(speeds[1]);
        frontRightDrive.set(speeds[0]);
        backRightDrive.set(speeds[3]);
        backLeftDrive.set(speeds[2]);

    }


	public double[] normalizeSpeeds(double[] speeds, double movementX, double movementY) {
		double maxSpeed = speeds[0];
		double minSpeed = speeds[0];
		// find min and max speeds
		for (int i = 1; i < speeds.length; i++) {
			if (speeds[i] > maxSpeed) {
				maxSpeed = speeds[i];
			}
			if (speeds[i] < minSpeed) {
				minSpeed = speeds[i];
			}
		}
		// normalize to fastest speed
		if (maxSpeed > 1) {
			for (int i = 0; i < speeds.length; i++) {
				speeds[i] /= maxSpeed;
			}
		}
		
		return speeds;
	}

	public void enable(){
		frontRightSwerve.reset();
		frontLeftSwerve.reset();
		backRightSwerve.reset();
		backLeftSwerve.reset();
	}

	public void disable(){
        
	}

	public static double diffBetweenDegrees(double a, double b){

        double r = (b - a) % 360.0;

        if(r < -180.0){
            r+= 360.0;
        }
        if(r >= 180){
            r-= 360.0;
        }

        return r;

    }

}

